<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WhatsApp Agent Dashboard</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome Icons CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
        xintegrity="sha512-SnH5WK+bZxgPHs44uWIX+LLMDJ8g2YJTIy2E/lKScVq4F3f9G5bQx2T/Bw2tI8g1e/Q71W+I4G9Fh7G9C0Q=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* Setup for Inter font and light theme body styles */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
            /* Very light, subtle background */
            min-height: 100vh;
        }

        /* Base Card Styling (Minimalist, sharp elevation) */
        .session-card {
            transition: all 0.2s ease-in-out;
            box-shadow: 2px 2px 0 0 rgba(0, 0, 0, 0.1);
            /* Sharp, distinct shadow */
            border-radius: 0.125rem;
            /* Extra subtle rounded edges (rounded-sm equivalent) */
        }

        .session-card:hover {
            box-shadow: 4px 4px 0 0 rgba(0, 0, 0, 0.15);
            transform: translate(-1px, -1px);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            min-width: 10px;
            min-height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        /* Action buttons refined for consistency */
        .action-btn {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.125rem;
            /* Sharp edges */
            transition: all 0.2s ease;
        }

        .action-btn:hover {
            transform: translateY(-1px);
        }

        /* Custom style for the pulsing button effect */
        .qr-pulse-btn {
            animation: pulse-ring 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse-ring {
            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(52, 211, 153, 0.7);
                /* Tailwind green-400 */
            }

            50% {
                box-shadow: 0 0 0 8px rgba(52, 211, 153, 0);
            }
        }

        /* Utility for showing loading state on a specific card */
        .starting-session {
            opacity: 0.6;
            pointer-events: none;
        }
    </style>
</head>

<body class="p-4 md:p-8">

    <!-- Main Application Container: Max width, centered, and sharp corners -->
    <div id="app" class="max-w-6xl mx-auto space-y-8 bg-white border border-black shadow-md p-0 rounded-sm">
        <!-- Header: Clean and defined -->
        <header class="flex justify-between items-center px-6 py-4 border-b border-black">
            <h1 class="text-2xl font-extrabold text-black tracking-tight">AGENT.OS <span
                    class="text-sm font-medium text-gray-500 ml-2">v1.0.1</span></h1>
            <div class="flex space-x-3">
                <!-- New Profile Button (Primary action) - NOW SHOWS MODAL -->
                <button id="new-profile-btn" class="action-btn bg-black text-white hover:bg-gray-800"
                    title="Create New Profile">
                    <i class="fas fa-plus text-base"></i>
                </button>
            </div>
        </header>


        <div class="flex flex-col space-y-8 p-6 pt-0">

            <!-- LIVE SESSIONS SECTION: Full width stack -->
            <section class="w-full">
                <h2 class="text-lg font-semibold text-black mb-4 border-b border-gray-300 pb-2">Live Sessions</h2>

                <!-- Live Sessions grid is now a simple vertical stack for full width -->
                <div id="live-sessions-grid" class="flex flex-col space-y-4">
                    <!-- Dynamic Live Session Cards will be injected here -->
                    <p class="text-gray-400 text-center py-4">Loading live sessions...</p>
                </div>
            </section>

            <!-- STORED SESSIONS SECTION: Two-column grid -->
            <section class="w-full">
                <div class="flex items-center justify-between mb-4 border-b border-gray-300 pb-2">
                    <h2 class="text-lg font-semibold text-black">Stored Profiles</h2>
                    <!-- Refresh/Retry Button moved here -->
                    <button onclick="fetchStoredProfiles()" id="refresh-btn"
                        class="action-btn bg-white text-gray-700 border border-gray-400 hover:bg-gray-100"
                        title="Refresh UI/Retry">
                        <i class="fas fa-sync text-sm"></i>
                    </button>
                </div>

                <!-- Grid container for stored profiles (populated by JS) -->
                <div id="stored-profiles-grid" class="grid grid-cols-1 md:grid-cols-2 gap-4 min-h-24">
                    <!-- Dynamic Stored Profile Cards/Loading state will be injected here -->
                </div>
            </section>

        </div>

        <script>
            // MAXIMUM number of status messages to display in the log
            const MAX_STATUS_LOG = 3;
            // Polling interval in milliseconds (3 seconds)
            const POLLING_INTERVAL = 3000; 

            // --- Utility Functions ---

            /**
             * Utility function to format milliseconds to HH:MM:SS
             */
            function formatUptime(ms) {
                if (ms < 0) ms = 0; // Prevent negative time
                const totalSeconds = Math.floor(ms / 1000);
                const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
                const minutes = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
                const seconds = String(totalSeconds % 60).padStart(2, '0');
                return `${hours}:${minutes}:${seconds}`;
            }

            /**
             * Utility function to format and style a single log message with a timestamp.
             * @param {string} message - The core status message.
             * @returns {string} The HTML string for the log entry.
             */
            function formatLogEntry(message) {
                // Generate a clean, compact 24-hour time string (HH:MM:SS)
                const timeString = new Date().toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
                // Wrap the time in a styled span for a compact, gray appearance
                return `<span class="font-mono text-[10px] text-gray-400 mr-2">[${timeString}]</span>${message}`;
            }

            /**
             * Displays a simple loading spinner in the stored profiles grid.
             */
            function showLoading() {
                const storedGrid = document.getElementById('stored-profiles-grid');
                storedGrid.innerHTML = `
                    <div class="col-span-1 md:col-span-2 flex justify-center items-center py-8">
                        <i class="fas fa-spinner fa-spin text-xl text-black mr-3"></i>
                        <span class="text-gray-600">Loading stored profiles...</span>
                    </div>
                `;
            }

            /**
             * Displays an error message in the stored profiles grid.
             */
            function showError(message) {
                const storedGrid = document.getElementById('stored-profiles-grid');
                storedGrid.innerHTML = `
                    <div class="col-span-1 md:col-span-2 flex justify-center items-center py-8 bg-red-50 border border-red-300 rounded-sm text-red-700">
                        <i class="fas fa-exclamation-triangle text-xl mr-3"></i>
                        <span>Error loading profiles: ${message}</span>
                    </div>
                `;
            }

            // --- Data Definitions (State) ---

            // Global state map to track which session details are open
            let expandedDetailsState = {};

            // Global state map to track which session is displaying the QR code view
            let qrCodeVisibleState = {};

            // Global state map to track which session is currently starting (API in progress)
            let startingSessionState = {};

            // Live sessions data (populated on load)
            let liveSessions = [];

            // Stored profiles data will be populated from the API fetch
            let storedProfiles = [];
            
            // Mock messages pool for the polling simulator
            const mockPollingMessages = [
                "Checked connection status: OK.",
                "Processed 1 new incoming message.",
                "Updated agent state to idle.",
                "Heartbeat signal sent successfully.",
                "Performing routine data sync.",
                "Outreach queue is empty.",
                "Logged successful activity.",
            ];
            let mockPollingMessageIndex = 0;


            // --- API Handler Functions (MOCK ACTIVE, REAL API COMMENTED OUT) ---

            /**
             * API Handler for GET /api/sessions/list
             * Retrieves a list of all currently active sessions (Live Sessions).
             */
       async function fetchLiveSessions() {
    const endpoint = '/api/sessions/list';
    showLoading?.(); // optional ‚Äî only if your UI uses this

    try {
        // Optional small delay for smooth UI transitions
        await new Promise(resolve => setTimeout(resolve, 300));

        const response = await fetch(endpoint, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (data.success && Array.isArray(data.sessions)) {
            // Transform API structure ‚Üí internal format (for compatibility with rest of the app)
            const NOW = Date.now();

            const sessions = data.sessions.map(session => ({
                id: session.session_id,
                name: session.profile_name || 'Unknown Profile',
                status: session.status?.toUpperCase() || 'UNKNOWN',
                icon: session.status === 'active' ? 'fas fa-play' : 'fas fa-stop',
                running: session.status === 'active',
                startTime: NOW, // no start time from API, so we use current time
                isPaused: false,
                qrCodeUrl: null, // your API doesn‚Äôt provide one
                isQrReady: false,
                statusLog: [
                    `<span class="font-mono text-[10px] text-gray-400 mr-2">[${new Date().toLocaleTimeString()}]</span>Session ${session.status}.`,
                    `<span class="font-mono text-[10px] text-gray-400 mr-2">[${new Date().toLocaleTimeString()}]</span>Driver: ${session.has_driver ? 'Available' : 'Missing'}.`,
                    `<span class="font-mono text-[10px] text-gray-400 mr-2">[${new Date().toLocaleTimeString()}]</span>Agents: autoreply=${session.agents?.autoreply}, auto_outreach=${session.agents?.auto_outreach}.`
                ]
            }));

            return {
                success: true,
                sessions,
                count: sessions.length
            };
        } else {
            console.error("Invalid API response format:", data);
            return { success: false, sessions: [], count: 0 };
        }

    } catch (error) {
        console.error("Error fetching live sessions:", error);
        return { success: false, sessions: [], count: 0 };
    }
}




            /**
             * MOCK API implementation for GET /api/sessions/{session_id}/status
             * Simulates fetching status updates during a dedicated poll.
             * @param {string} sessionId - The ID of the session.
             * @returns {Promise<Object>} Mock API response with status and log data.
             */
          

            // Mock Data that simulates the real API response structure
            const MOCK_API_RESPONSE_GET_PROFILES = {
                "success": true,
                "profiles": [
                    { "encoded_session_id": "test-001_sales", "base_uuid": "test-001_sales", "profile_name": "Sales Flow", "is_active": false },
                    { "encoded_session_id": "e148df19-1cd0-42ea-b9f1-fa3edefd45e5", "base_uuid": "e148df19-1cd0-42ea-b9f1-fa3edefd45e5", "profile_name": "Marketing Campaign 2024", "is_active": false },
                    { "encoded_session_id": "3e17e7f2-2981-4ee8-904f-879f06972cc3_acount1", "base_uuid": "3e17e7f2-2981-4ee8-904f-879f06972cc3_acount1", "profile_name": "Weekly Digest Sender", "is_active": false },
                    { "encoded_session_id": "55125007-3c63-4d59-bf19-548af3818b1c", "base_uuid": "55125007-3c63-4d59-bf19-548af3818b1c", "profile_name": "HR Onboarding Automation", "is_active": false }
                ],
                "count": 4
            };

            /**
             * MOCK API implementation for POST /api/sessions/create
             */
            async function mockCreateSession(profileName) {
                // --- REAL API CALL (Commented Out) ---
                /* ... (Code is unchanged from previous step) ... */
                // -------------------------------------

                console.log(`[MOCK API] POST /api/sessions/create called with name: ${profileName}`);
                await new Promise(resolve => setTimeout(resolve, 1500)); 

                const newId = `c${Date.now()}-${Math.floor(Math.random() * 9999)}`;
                const sessionId = `${newId}||${btoa(profileName.replace(/\s/g, '_'))}`;

                return {
                    "success": true,
                    "message": "Session created with profile 'string' and driver initialized: Driver initialized and blank tab opened",
                    "data": {
                        "session_id": sessionId,
                        "profile_name": profileName
                    }
                };
            }


          /**
 * Real API implementation for POST /api/sessions/resume
 */
/**
 * Real API implementation for POST /api/sessions/resume
 * (Compatible with FastAPI query parameters)
 */
async function resumeSession(sessionId, headless = True) {
    const endpoint = `/api/sessions/resume?session_id=${encodeURIComponent(sessionId)}&headless=${headless}`;

    try {
        console.log(`[API] POST ${endpoint}`);

        const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Accept': 'application/json' }
            // ‚ö†Ô∏è DO NOT send JSON body ‚Äî FastAPI expects query params only
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (data.success) {
            console.log(`‚úÖ ${data.message}`);
            return {
                success: true,
                message: data.message,
                data: data.data
            };
        } else {
            console.error("API returned success: false", data);
            return {
                success: false,
                message: data.message || 'Failed to resume session.'
            };
        }

    } catch (error) {
        console.error("Error resuming session:", error);
        return {
            success: false,
            message: 'Could not connect to the API endpoint.'
        };
    }
}


            
            /**
             * MOCK API implementation for POST /api/sessions/{session_id}/stop
             */
            async function mockStopSession(sessionId) {
                // --- REAL API CALL (Commented Out) ---
                const endpoint = `/api/sessions/${sessionId}/stop`;
                try {
                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                        // No body required for this endpoint
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    // The expected successful response structure:
                    // { "success": true, "message": "Session stopped (profile saved)", "data": null }
                    return await response.json();
                } catch (error) {
                    console.error("Error stopping session:", error);
                    return { success: false, message: "Network error during session stop." };
                }
                // -------------------------------------
                
                console.log(`[MOCK API] POST /api/sessions/${sessionId}/stop called.`);
                await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate API latency

                return {
                    "success": true,
                    "message": "Session stopped (profile saved)",
                    "data": null
                };
            }


            /**
             * Fetches stored profiles from the API and updates the global state.
             */
          async function fetchStoredProfiles() {
    showLoading();
    const endpoint = '/api/sessions/profiles';

    try {
        // Optional: artificial delay for smooth UI
        await new Promise(resolve => setTimeout(resolve, 500)); 

        const response = await fetch(endpoint, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const data = await response.json();

        if (data.success && Array.isArray(data.profiles)) {
            storedProfiles = data.profiles.map(p => ({
                id: p.encoded_session_id,
                name: p.profile_name || 'Unknown Profile',
                status: p.is_active ? 'RUNNING' : 'STOPPED',
                running: p.is_active,
            }));

            renderDashboard();
            console.log(`Successfully loaded ${storedProfiles.length} stored profiles.`);
        } else {
            showError("API returned success: false or invalid format.");
            console.error("API Fetch Error: Invalid response structure", data);
        }

    } catch (error) {
        showError("Could not connect to the API endpoint.");
        console.error("Fetch failed:", error);
    }
}

            
            // --- POLLING LOGIC ---

            /**
             * The dedicated polling function for a single live session.
             * It calls the mock status API, updates the session's log and status,
             * and then triggers a re-render.
             * @param {object} session - The live session object to update.
             */

async function sessionPolling(session) {
    console.log(`[sessionPolling] üîÑ Polling started for session: ${session.id}`);

    if (!session.running || session.isPaused) {
        console.log(`[sessionPolling] ‚è∏Ô∏è Skipped polling ‚Äî running=${session.running}, isPaused=${session.isPaused}`);
        return;
    }

    try {
        console.log(`[sessionPolling] Fetching messages from API...`);
        const response = await fetchSessionMessages(session.id);

        if (response.success) {
            const messages = response.data;
            console.log(`[sessionPolling] ‚úÖ Received ${messages.length} messages for ${session.id}`);

            if (!Array.isArray(messages) || messages.length === 0) {
                console.warn(`[sessionPolling] ‚ö†Ô∏è No messages found for session ${session.id}`);
                return;
            }

            // ---- Process the latest 3 messages ----
            const latestMessages = messages.slice(-3).reverse(); // newest first
            console.log(`[sessionPolling] Processing latest 3 messages:`, latestMessages);

            for (const msg of latestMessages) {
                console.log(`[sessionPolling] ‚Üí Handling message type: ${msg.type}`, msg);

                switch (msg.type) {
                    case "status":
                        handleStatusMessage(session, msg);
                        break;
                    case "log":
                        handleLogMessage(session, msg);
                        break;
                    case "action":
                        await handleActionMessage(session, msg);
                        break;
                    default:
                        console.warn(`[sessionPolling] ‚ö†Ô∏è Unknown message type: ${msg.type}`, msg);
                }
            }

            // Limit stored logs
            if (session.statusLog.length > MAX_STATUS_LOG) {
                console.log(`[sessionPolling] üßπ Trimming statusLog (length=${session.statusLog.length})`);
                session.statusLog = session.statusLog.slice(0, MAX_STATUS_LOG);
            }

            console.log(`[sessionPolling] ‚úÖ Rendering dashboard update...`);
            renderDashboard();

        } else {
            console.warn(`[sessionPolling] ‚ùå Polling failed for ${session.id}: ${response.message}`);
            addLiveStatus(session.id, `<span class="text-red-500">POLL ERROR: ${response.message.substring(0, 30)}...</span>`);
        }

    } catch (error) {
        console.error(`[sessionPolling] üö® NETWORK ERROR during poll for ${session.id}`, error);
        addLiveStatus(session.id, `<span class="text-red-500">NETWORK FAILED: Check API.</span>`);
    }
}

async function fetchSessionMessages(sessionId) {
    const endpoint = `/api/sessions/${encodeURIComponent(sessionId)}/messages`;
    console.log(`[fetchSessionMessages] üåê Fetching from ${endpoint}`);

    try {
        const res = await fetch(endpoint, {
            method: 'GET',
            headers: { 'Accept': 'application/json' },
        });

        console.log(`[fetchSessionMessages] HTTP status: ${res.status}`);

        if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
        }

        const data = await res.json();
        console.log(`[fetchSessionMessages] Response JSON:`, data);

        if (!data.messages) {
            return { success: false, message: "No messages found." };
        }

        return { success: true, data: data.messages };

    } catch (error) {
        console.error("[fetchSessionMessages] ‚ùå Error fetching session messages:", error);
        return { success: false, message: "Network or parsing error during fetch." };
    }
}

// üü¢ HANDLERS
function handleStatusMessage(session, msg) {
    console.log(`[handleStatusMessage] Handling STATUS message for ${session.id}`, msg);
    const { state, message, progress } = msg.content;

    session.status = state?.toUpperCase() || "UNKNOWN";
    session.icon = getStatusIcon(session.status);
updateLiveSessionStatus(session.id, message, "fas fa-times-circle");

}

function handleLogMessage(session, msg) {
    console.log(`[handleLogMessage] Handling LOG message for ${session.id}`, msg);
    const { message, level } = msg.content;
    const formatted = `[${level?.toUpperCase() || "INFO"}] ${message}`;
    session.statusLog.unshift(formatLogEntry(formatted));
}

async function handleActionMessage(session, msg) {
    console.log(`[handleActionMessage] Handling ACTION message for ${session.id}`, msg);
    const { action_type, message, data } = msg.content;


    if (action_type === "SHOW_QR") {
        console.log(`[handleActionMessage] üß≠ Detected SHOW_QR action, fetching QR from API...`);

        try {
            const endpoint = `/api/sessions/${encodeURIComponent(session.id)}/whatsapp/qr-code`;
            console.log(`[handleActionMessage] üåê GET ${endpoint}`);
            const qrResponse = await fetch(endpoint, {
                method: "GET",
                headers: { "Accept": "application/json" },
            });

            console.log(`[handleActionMessage] HTTP status: ${qrResponse.status}`);

            if (!qrResponse.ok) {
                throw new Error(`QR fetch failed: ${qrResponse.status}`);
            }

            const qrData = await qrResponse.json();
            console.log(`[handleActionMessage] QR API Response:`, qrData);

            if (qrData.success && qrData.qr_code) {
                console.log(`[handleActionMessage] ‚úÖ Valid QR received, showing code...`);
                session.statusLog.unshift(formatLogEntry("‚úÖ QR code fetched successfully"));
                showQrCode(session.id, `${qrData.qr_code}`);
            } else {
                console.warn(`[handleActionMessage] ‚ö†Ô∏è Invalid or missing QR data`, qrData);
                session.statusLog.unshift(formatLogEntry("‚ö†Ô∏è Failed to get valid QR data"));
            }

        } catch (error) {
            console.error(`[handleActionMessage] ‚ùå Error fetching WhatsApp QR:`, error);
            session.statusLog.unshift(formatLogEntry("‚ùå Error fetching WhatsApp QR"));
        }
    } 
    else if(action_type === "HIDE_QR"){
        hideQrCode(session.id)
    }
    else {
        console.log(`[handleActionMessage] ‚ÑπÔ∏è Non-QR action detected: ${action_type}`);
    }
}




// üîß HELPERS
function getStatusIcon(status) {
    console.log(`[getStatusIcon] Resolving icon for status=${status}`);
    switch (status.toLowerCase()) {
        case 'running': return 'fas fa-circle-notch fa-spin';
        case 'active': return 'fas fa-play-circle';
        case 'error': return 'fas fa-exclamation-triangle';
        case 'unreachable': return 'fas fa-times-circle';
        case 'completed': return 'fas fa-check-circle text-green-500';
        default: return 'fas fa-question-circle';
    }
}

function formatLogEntry(message) {
    const timestamp = new Date().toLocaleTimeString();
    return `[${timestamp}] ${message}`;
}


function formatLogEntry(message) {
    const timestamp = new Date().toLocaleTimeString();
    return `[${timestamp}] ${message}`;
}



            /**
             * Starts the master polling interval that calls sessionPolling for every live session.
             */
            function startMasterPollingLoop() {
                // Clear any existing master interval to prevent duplicates
                if (window.masterPollingInterval) {
                    clearInterval(window.masterPollingInterval);
                }
                
                window.masterPollingInterval = setInterval(() => {
                    // Iterate over a copy of the liveSessions array to avoid issues if the array changes during iteration
                    liveSessions.forEach(session => {
                        // Only poll sessions that are actively running and not paused
                        if (session.running && !session.isPaused) {
                            sessionPolling(session);
                        }
                    });
                }, POLLING_INTERVAL);
                
                console.log(`Master polling loop started, updating every ${POLLING_INTERVAL / 1000} seconds.`);
            }


            // --- Modal Functions (Unchanged) ---

            /**
             * Shows the New Session modal.
             */
            function showModal() {
                document.getElementById('new-session-modal').classList.remove('hidden');
                document.getElementById('session-name-input').focus();
            }

            /**
             * Hides the New Session modal and clears the input.
             */
            function hideModal() {
                document.getElementById('new-session-modal').classList.add('hidden');
                document.getElementById('session-name-input').value = ''; // Clear input
                document.getElementById('session-name-input').classList.remove('border-red-500');
                // Ensure button state is reset
                const button = document.getElementById('create-session-button');
                button.innerHTML = 'Create Session';
                button.disabled = false;
            }

            /**
             * Handles the submission from the modal, calling the mock creation API.
             */
async function submitNewSession() {
    const inputElement = document.getElementById('session-name-input');
    const button = document.getElementById('create-session-button');
    const sessionName = inputElement.value.trim();

    if (!sessionName) {
        inputElement.placeholder = "Name is required!";
        inputElement.classList.add('border-red-500');
        setTimeout(() => {
            inputElement.classList.remove('border-red-500');
            inputElement.placeholder = "Enter session name (e.g., Test Agent)";
        }, 1500);
        return;
    }

    // Show loading state
    button.disabled = true;
    button.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Creating...';

    try {
        // --- REAL API CALL ---
        const response = await fetch('/api/sessions/create', {
            method: 'POST',
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                profile_name: sessionName,
                session_type: 'whatsapp',   // or dynamically set if needed
                config: {},                 // add any additional config here
                headless: false
            })
        });

        const apiResponse = await response.json();

        if (response.ok && apiResponse.success) {
            console.log(`SUCCESS: Session created. ID: ${apiResponse.data.session_id}`);
            // Add the new session to the live list
            createNewLiveSession(apiResponse.data.session_id, apiResponse.data.profile_name);
            hideModal(); // Hide modal on success
        } else {
            console.error(`FAILURE: API Create failed. Message: ${apiResponse.message}`);
            inputElement.classList.add('border-red-500');
            setTimeout(() => inputElement.classList.remove('border-red-500'), 2000);
            button.innerHTML = 'Error';
            setTimeout(() => {
                button.innerHTML = 'Create Session';
                button.disabled = false;
            }, 1000);
        }
    } catch (error) {
        console.error("Network or script error during session creation:", error);
        button.innerHTML = 'Network Error';
        setTimeout(() => {
            button.innerHTML = 'Create Session';
            button.disabled = false;
        }, 2000);
    }
}




            // --- State Management Functions ---

            /**
             * Creates and starts a new live session based on the provided API response data.
             */
            function createNewLiveSession(sessionId, sessionName) {
                const newSession = {
                    id: sessionId,
                    name: sessionName,
                    status: 'INITIALIZING', // Start state
                    icon: 'fas fa-spinner fa-spin',
                    running: true,
                    startTime: Date.now(),
                    isPaused: false,
                    qrCodeUrl: `https://wa.me/qr/NEW-${sessionId.substring(0, 8)}`,
                    isQrReady: false, // Start as not ready, QR will be generated
                    statusLog: [
                        formatLogEntry('New session initiated via API.'),
                        formatLogEntry(`Process ID: ${sessionId.substring(0, 8)}...`),
                        formatLogEntry('Awaiting driver initialization...')
                    ]
                };

                liveSessions.unshift(newSession); // Add to the start of live sessions
                renderDashboard();
                // Optionally trigger the QR ready state a few seconds later for demo
            }


            /**
             * Adds a new message to a live session's status log, removing the oldest if limit is exceeded.
             */
            function addLiveStatus(id, message) {
                const session = liveSessions.find(s => s.id === id);
                if (session) {
                    // Use the utility function to format the message and timestamp
                    session.statusLog.unshift(formatLogEntry(message));

                    // Enforce the maximum log length
                    if (session.statusLog.length > MAX_STATUS_LOG) {
                        session.statusLog.pop(); // Remove the oldest message from the end
                    }

                    // Re-render the dashboard to reflect the updated status log
                    renderDashboard();
                }
            }

            /**
             * Updates the status text and icon for a specific live session.
             */
            function updateLiveSessionStatus(id, newStatus, newIcon) {
                const session = liveSessions.find(s => s.id === id);
                if (session) {
                    session.status = newStatus;
                    session.icon = newIcon;
                    renderDashboard(); // Re-render the affected card
                }
            }

            /**
             * Toggles the pause/run state of a live session.
             */
            function toggleSessionPause(id) {
                console.log(`Action: Toggling pause/play for session ID: ${id}`);
                const session = liveSessions.find(s => s.id === id);

                if (session && session.running) {
                    session.isPaused = !session.isPaused;

                    if (session.isPaused) {
                        // Pause action: Set status to PAUSED and icon to static pause
                        updateLiveSessionStatus(id, 'PAUSED', 'fas fa-pause');
                    } else {
                        // Resume action: Set status back to RUNNING and icon to spinning
                        const newStatus = session.name.toLowerCase().includes('bot') ? 'CONNECTING' : 'RUNNING';
                        const newIcon = 'fas fa-circle-notch fa-spin';
                        updateLiveSessionStatus(id, newStatus, newIcon);
                    }
                }
            }

            /**
             * Makes an API call to resume a session and moves it from storedProfiles to liveSessions (starts the session).
             */
            async function startSession(id) {
                console.log(`Action: Attempting to start/resume session ID: ${id}`);
                const profileIndex = storedProfiles.findIndex(s => s.id === id);
                const cardElement = document.getElementById(`profile-${id}`);

                if (profileIndex === -1) {
                    console.error(`Profile with ID ${id} not found in stored list.`);
                    return;
                }

                const profileToStart = storedProfiles[profileIndex];

                // Add a temporary loading state to the card while API call is running
                if (cardElement) cardElement.classList.add('starting-session');
                startingSessionState[id] = true;
                renderDashboard(); 

                try {
                    // 1. CALL THE RESUME API
                    const response = await resumeSession(id, false);

                    if (response.success) {
                        console.log(`SUCCESS: Session ${profileToStart.name} resumed via API.`);

                        // 2. STATE TRANSITION: Move session from Stored to Live
                        const session = storedProfiles.splice(profileIndex, 1)[0];

                        session.running = true;
                        session.isPaused = false;
                        session.status = 'RUNNING';
                        session.icon = 'fas fa-circle-notch fa-spin';
                        session.startTime = Date.now();
                        session.qrCodeUrl = `https://wa.me/qr/RESUME-${id.substring(0, 8)}`;
                        session.isQrReady = false; // Will become ready after a mock delay

                        session.statusLog = [
                            formatLogEntry(`Session resumed successfully: ${response.data.profile_name || session.name}`),
                            formatLogEntry('Initializing communication channels.'),
                            formatLogEntry(`Started at: ${new Date().toLocaleTimeString()}`)
                        ];
                        liveSessions.push(session);
                        // Trigger QR ready state after a short delay

                    } else {
                        console.error(`FAILURE: API Resume failed for ${profileToStart.name}. Message: ${response.message}`);
                        if (cardElement) {
                            cardElement.style.borderColor = 'red';
                            setTimeout(() => cardElement.style.borderColor = 'gray', 2000);
                        }
                    }
                } catch (error) {
                    console.error(`NETWORK ERROR: Could not complete resume API call for ${profileToStart.name}`, error);
                } finally {
                    // 3. CLEAN UP LOADING STATE
                    delete startingSessionState[id];
                    if (cardElement) cardElement.classList.remove('starting-session');
                    renderDashboard();
                }
            }


            /**
             * Makes an API call to stop a session and moves it from liveSessions to storedProfiles.
             */
            async function stopSession(id) {
                console.log(`Action: Attempting to stop session ID: ${id}`);
                const sessionIndex = liveSessions.findIndex(s => s.id === id);
                const cardElement = document.getElementById(`profile-${id}`);

                if (sessionIndex === -1) {
                    console.error(`Session with ID ${id} not found in live list.`);
                    return;
                }
                
                if (cardElement) cardElement.classList.add('starting-session');
                startingSessionState[id] = true;
                renderDashboard(); 

                try {
                    // 1. CALL THE STOP API
                    const response = await mockStopSession(id);

                    if (response.success) {
                        console.log(`SUCCESS: Session ${id} stopped and profile saved.`);

                        // 2. STATE TRANSITION: Move session from Live to Stored
                        const session = liveSessions.splice(sessionIndex, 1)[0];
                        
                        // Clean up live session specific properties
                        session.running = false;
                        session.status = 'STOPPED';
                        delete session.icon;
                        delete session.startTime; 
                        delete session.statusLog; 
                        delete session.isPaused; 
                        delete session.qrCodeUrl;
                        delete session.isQrReady; 

                        // Cleanup: Remove expanded state when session stops
                        delete expandedDetailsState[id];
                        delete qrCodeVisibleState[id]; 

                        storedProfiles.push(session);
                    } else {
                        console.error(`FAILURE: API Stop failed for ${id}. Message: ${response.message}`);
                        if (cardElement) {
                            cardElement.style.borderColor = 'red';
                            setTimeout(() => cardElement.style.borderColor = 'gray', 2000);
                        }
                    }
                } catch (error) {
                    console.error(`NETWORK ERROR: Could not complete stop API call for ${id}`, error);
                } finally {
                    // 3. CLEAN UP LOADING STATE
                    delete startingSessionState[id];
                    if (cardElement) cardElement.classList.remove('starting-session');
                    renderDashboard();
                }
            }

            /**
             * Deletes a profile/session from its current list.
             */
async function deleteProfile(id) {
    console.log(`Action: Deleting profile ID: ${id}`);

    try {
        const response = await fetch(`/api/sessions/${id}`, {
            method: 'DELETE',
            headers: {
                'Accept': 'application/json'
            }
        });

        const result = await response.json();

        if (response.ok && result.success) {
            console.log('Session deleted successfully:', result.message);

            // Remove from liveSessions or storedProfiles
            const liveIndex = liveSessions.findIndex(s => s.id === id);
            if (liveIndex > -1) {
                liveSessions.splice(liveIndex, 1);
                delete expandedDetailsState[id];
                delete qrCodeVisibleState[id];
            } else {
                const storedIndex = storedProfiles.findIndex(s => s.id === id);
                if (storedIndex > -1) {
                    storedProfiles.splice(storedIndex, 1);
                }
            }

            renderDashboard();
        } else {
            console.error('Failed to delete session:', result.message);
        }
    } catch (err) {
        console.error('Error deleting session:', err);
    }
}


            /**
             * Toggles the visibility of the session details container and icon.
             */
            function toggleDetails(id) {
                console.log(`Action: Toggling details for session ID: ${id}`);
                expandedDetailsState[id] = !expandedDetailsState[id];
                renderDashboard();
            }

            // --- QR FUNCTIONS ---

            /**
             * Marks the QR code as ready for scanning by setting the URL and making the
             * pulsing 'Show QR Code' button appear.
             */
            function showQrCode(id, url) {
                console.log(`Action: Marking QR code available for session ID: ${id} with URL: ${url}`);
                const session = liveSessions.find(s => s.id === id);
                if (session) {
                    session.qrCodeUrl = url;
                    session.isQrReady = true;
                    renderDashboard();
                }
            }

            /**
             * Toggles the visibility of the full QR code display card.
             */
            function showQrView(id) {
                console.log(`Action: Toggling ON QR Code View for session ID: ${id}`);
                qrCodeVisibleState[id] = true;
                delete expandedDetailsState[id]; // Ensure details are hidden
                renderDashboard();
            }

            /**
             * Hides the QR code interface, returns to the default info compact card,
             * and clears the QR ready flag so the pulsing button disappears.
             */
            function hideQrCode(id) {
                console.log(`Action: Hiding QR code and clearing readiness for session ID: ${id}`);
                const session = liveSessions.find(s => s.id === id);
                if (session) {
                    session.isQrReady = false; // Hide the pulsing button
                }
                delete qrCodeVisibleState[id];
                renderDashboard();
            }

            /**
             * Updates the uptime display for all live sessions without re-rendering the whole grid.
             */
            function updateTimers() {
                const now = Date.now();
                liveSessions.forEach(session => {
                    if (session.running && session.startTime && !session.isPaused) {
                        const uptimeElement = document.getElementById(`uptime-${session.id}`);
                        if (uptimeElement) {
                            const uptimeMs = now - session.startTime;
                            uptimeElement.textContent = formatUptime(uptimeMs);
                        }
                    }
                });
            }


            // --- Component-like Function (View) ---

            /**
             * Generates the HTML string for a single session card using only B&W theme.
             */
            function createSessionCard(session) {
                const isLive = session.running;

                const isBusy = !!startingSessionState[session.id];

                const activeDotColor = 'bg-black';
                const stoppedDotColor = 'bg-gray-500';

                const cardClasses = isLive
                    ? `bg-gray-50 border border-black`
                    : `bg-white border border-gray-400`;
                const dividerClass = isLive ? 'border-gray-300' : 'border-gray-200';

                const busyClass = isBusy ? 'starting-session' : '';


                let actionButtonsHTML = '';
                                let statusRowHTML = ''; // NEW ROW 1.5

                let detailsHTML = '';

                const statusIcon = isLive && session.icon ? `<i class="${session.icon} mr-1"></i>` : '';

                if (isLive) {

                    const isQrCodeVisible = !!qrCodeVisibleState[session.id];
                    const isQrButtonReady = session.isQrReady && session.qrCodeUrl && !isQrCodeVisible;

                    const uptimeMs = Date.now() - session.startTime;
                    const runTime = formatUptime(uptimeMs);

                    const isPaused = session.isPaused;
                    const pausePlayIcon = isPaused ? 'fas fa-play' : 'fas fa-pause';
                    const pausePlayTitle = isPaused ? 'Resume Session' : 'Pause Session';
                    const pausePlayClasses = isPaused
                        ? 'bg-black text-white hover:bg-gray-800'
                        : 'bg-white text-black border border-gray-400 hover:bg-gray-200';

                    const isDetailsExpanded = !!expandedDetailsState[session.id];

                    const hiddenClass = isQrCodeVisible || isDetailsExpanded ? '' : 'hidden';
                    const chevronIconClass = isDetailsExpanded ? 'fa-chevron-up' : 'fa-chevron-down'; 
 // NEW: Permanent Status Row Content (Row 1.5)
const statusLogHTML = (session.statusLog || [])
  .slice(0, 1)
  .map(log => `<li class="truncate"><div class="flex items-start">${log}</div></li>`)
  .join('');

                    // This row is always displayed for live, non-QR view
                    if (!isQrCodeVisible) {
                    statusRowHTML = `
                        <div class="flex justify-between items-center flex-shrink-0 pt-1 pb-2 border-b border-gray-300 mb-3">
                            <span class="text-xs font-semibold uppercase text-black tracking-wider">
                                ${statusIcon} ${session.status}
                            </span>
                              <!-- List style changed to list-none for cleaner log stacking -->
                                    <ul id="status-log-${session.id}" class="text-xs text-gray-600 mt-2 space-y-1 list-none">
                                        ${statusLogHTML}
                                    </ul>
                        </div>
                    `;
                    }
                    
                    if (isQrCodeVisible) {
                        // 1. QR CODE VIEW
                        actionButtonsHTML = `
                            <!-- Back to Status Button (Primary) -->
                            <button onclick="hideQrCode('${session.id}')"
                                class="action-btn bg-black text-white hover:bg-gray-800"
                                title="Back to Status / Clear QR">
                                <i class="fas fa-arrow-left text-xs"></i>
                            </button>
                            <!-- Stop Button (Secondary) -->
                            <button onclick="stopSession('${session.id}')"
                                class="action-btn bg-white text-gray-700 border border-gray-400 hover:bg-gray-100"
                                title="Stop Session" ${isBusy ? 'disabled' : ''}>
                                <i class="fas fa-stop text-sm"></i>
                            </button>
                        `;

                        detailsHTML = `
                            <div class="pt-3 border-t border-gray-300">
                                <p class="text-sm font-semibold text-black mb-2">Scan QR Code to Connect</p>
                                <div class="flex items-center justify-center p-8 bg-white border border-black shadow-inner">
                                    <div class="w-40 h-40 flex items-center justify-center bg-gray-200 border border-dashed border-gray-500 rounded-sm">
                            <img src="${session.qrCodeUrl}" class="w-full h-full" alt="image" />
                                    </div>
                                </div>
                                <p class="mt-3 text-xs text-gray-600 truncate">
                                    **Session ID:** <span class="font-mono text-xs text-black">${session.id}</span>
                                </p>
                                <p class="mt-1 text-xs text-gray-600 truncate">
                                    **URL:** <a href="${session.qrCodeUrl}" target="_blank" class="text-blue-600 hover:underline">${session.qrCodeUrl}</a>
                                </p>
                            </div>
                        `;

                    } else {
                        // 2. STATUS VIEW (Default/Expanded)
                        const showQrButton = isQrButtonReady
                            ? `
                            <!-- Show QR Code Button (Pulsing) -->
                            <button onclick="showQrView('${session.id}')"
                                class="action-btn qr-pulse-btn bg-white text-green-600 border border-green-400 hover:bg-green-100"
                                title="QR Code Ready - Click to Scan" ${isBusy ? 'disabled' : ''}>
                                <i class="fas fa-qrcode text-sm"></i>
                            </button>
                            `
                            : '';


                        // Live Session Buttons
                        actionButtonsHTML = `
                            ${showQrButton}
                            <!-- Pause/Play Toggle Button -->
                            <button onclick="toggleSessionPause('${session.id}')"
                                class="action-btn ${pausePlayClasses}"
                                title="${pausePlayTitle}" ${isBusy ? 'disabled' : ''}>
                                <i class="${pausePlayIcon} text-xs"></i>
                            </button>

                            <!-- Stop Button (White/Gray) -->
                            <button onclick="stopSession('${session.id}')"
                                class="action-btn bg-white text-gray-700 border border-gray-400 hover:bg-gray-100"
                                title="Stop Session" ${isBusy ? 'disabled' : ''}>
                                <i class="fas fa-stop text-sm"></i>
                            </button>
                            <!-- Toggle Details Button (Chevron for show/hide details) -->
                            <button onclick="toggleDetails('${session.id}')"
                                class="action-btn bg-white text-gray-700 border border-gray-400 hover:bg-gray-100"
                                title="Toggle Details" ${isBusy ? 'disabled' : ''}>
                                <!-- CHEVRON ICON CLASS is dynamically set based on state -->
                                <i class="fa-solid ${chevronIconClass}" id="chevron-icon-${session.id}"></i>
                            </button>   <!-- More Options Button -->
 <!-- More Options Button -->
    <button onclick="window.location.href='session.html?id=${session.id}'"
        class="action-btn bg-white text-gray-700 border border-gray-400 hover:bg-gray-100"
        title="Manage Session">
        <i class="fas fa-ellipsis-h text-sm"></i>
    </button>
                        `;

                        const sessionType = session.name.toLowerCase().includes('bot') ? 'BOT AUTOMATION' : 'OUTREACH FLOW';
                        const convCount = session.id === 'p3-3' ? '1,402' : (session.id === 'p3-2' ? '003' : '000');

                        const statusLogHTML = (session.statusLog || []).map(log => `<li class="truncate"><div class="flex items-start">${log}</div></li>`).join('');


                        detailsHTML = `
                            <div id="details-container-${session.id}" class="pt-3 border-t grid grid-cols-4 border-gray-300 ${hiddenClass}">

                                <!-- Col 1 (75% width): Detailed Status and Messages -->
                                <div class="col-span-3 pr-4">
                                    <div class="flex items-center flex-shrink-0 pt-0.5">
                                        <span class="text-xs font-semibold uppercase text-black tracking-wider">
                                            ${statusIcon} ${session.status}
                                        </span>
                                    </div>
                                    <!-- List style changed to list-none for cleaner log stacking -->
                                    <ul id="status-log-${session.id}" class="text-xs text-gray-600 mt-2 space-y-1 list-none">
                                        ${statusLogHTML}
                                    </ul>
                                </div>


                                <!-- Col 2 (25% width): Compact Metrics Card (Monochrome) -->
                                <div class="col-span-1 flex justify-end">
                                    <div class="w-full max-w-[140px] p-2 border border-black bg-gray-100 rounded-sm">

                                        <!-- Session Type -->
                                        <div class="border-b border-gray-300 pb-1 mb-1">
                                            <span class="font-mono text-[10px] font-bold text-black uppercase leading-none block truncate">
                                                ${sessionType}
                                            </span>
                                        </div>

                                        <!-- Running Time - This element is targeted by the updateTimers function -->
                                        <div class="flex justify-between items-center text-xs mb-1">
                                            <p class="text-gray-600">UPTIME:</p>
                                            <p id="uptime-${session.id}" class="font-mono font-bold text-black">${runTime}</p>
                                        </div>

                                        <!-- Conversations -->
                                        <div class="flex justify-between items-center text-xs">
                                            <p class="text-gray-600">CONVS:</p>
                                            <p class="font-mono font-bold text-black">${convCount}</p>
                                        </div>

                                    </div>
                                </div>
                            </div>
                        `;
                    }
                } else {
                    // Stored Profile Buttons
                    const startButtonContent = isBusy
                        ? `<i class="fas fa-spinner fa-spin text-sm"></i>` 
                        : `<i class="fas fa-play text-xs"></i>`; 

                    const startButtonTitle = isBusy ? 'Starting...' : 'Start Session';
                    const startButtonClasses = isBusy
                        ? 'bg-gray-400 text-white' 
                        : 'bg-black text-white hover:bg-gray-800';

                    actionButtonsHTML = `
                        <!-- Start Button -->
                        <button onclick="startSession('${session.id}')"
                            class="action-btn ${startButtonClasses}" title="${startButtonTitle}"
                            ${isBusy ? 'disabled' : ''}>
                            ${startButtonContent}
                        </button>
                        <!-- Delete Button -->
                        <button onclick="deleteProfile('${session.id}')"
                            class="action-btn bg-white text-gray-700 border border-gray-400 hover:bg-gray-100"
                            title="Delete Profile" ${isBusy ? 'disabled' : ''}>
                            <i class="fas fa-trash-alt text-sm"></i>
                        </button>
                    `;

                    detailsHTML = `
                        <p class="text-sm text-gray-600 pt-3 border-t ${dividerClass} truncate">Profile stopped and stored. ID: <span class="font-mono text-xs text-black">${session.id}</span></p>
                    `;
                }


                return `
                    <div id="profile-${session.id}" class="session-card flex flex-col p-4 rounded-sm ${cardClasses} ${busyClass}">
                        <!-- ROW 1: Status Indicator (Dot) & Profile Name & Action Buttons -->
                        <div class="flex justify-between items-start mb-3">
                            <!-- Status Indicator and Text -->
                          <p class="text-sm font-semibold text-gray-800 flex items-center">
                                                            <span class="status-dot ${isLive ? activeDotColor : stoppedDotColor} mr-2">  </span>

                                <span class="font-mono ml-1 text-black">${session.name}</span>
                            </p>
                            <!-- Action Buttons -->
                            <div class="flex space-x-2 flex-shrink-0">
                                ${actionButtonsHTML}
                            </div>
                        </div>
                        <!-- NEW ROW 1.5: Permanent Live Status Display -->
                        ${statusRowHTML}
                        <!-- ROW 2: Profile Name / Status Details -->
                        ${detailsHTML}
                    </div>
                `;
            }

            // --- Rendering Logic (Controller) ---

            /**
             * Renders the entire dashboard based on the current state of liveSessions and storedProfiles.
             */
            function renderDashboard() {
                const liveGrid = document.getElementById('live-sessions-grid');
                const storedGrid = document.getElementById('stored-profiles-grid');

                if (liveGrid) {
                    liveGrid.innerHTML = liveSessions.map(createSessionCard).join('');
                }

                if (storedGrid) {
                    storedGrid.innerHTML = storedProfiles.map(createSessionCard).join('');
                }
            }


            // --- Event Listeners and Initialization ---

            document.addEventListener('DOMContentLoaded', async () => {
                // 1. Fetch Live Sessions
                const liveData = await fetchLiveSessions();
                if (liveData.success) {
                    liveSessions = liveData.sessions;
                } else {
                    console.error("Failed to load initial live sessions.");
                }
                
                // 2. Fetch Stored Profiles
                fetchStoredProfiles();

                // 3. Connect Header Buttons to functions
                document.getElementById('new-profile-btn').onclick = showModal;

                // 4. Start the Uptime timer loop (1 second interval)
                setInterval(updateTimers, 1000);

                // 5. Start the NEW Master Polling Loop (3 second interval for all live sessions)
                startMasterPollingLoop();

                // Initial render now relies on data loaded above
                renderDashboard(); 
            });
        </script>
    </div>

    <!-- New Session Modal Dialog -->
    <div id="new-session-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-6 rounded-sm shadow-2xl w-full max-w-sm border border-black">
            <h3 class="text-xl font-bold mb-4">Create New Live Session</h3>
            <input type="text" id="session-name-input"
                placeholder="Enter session name (e.g., Test Agent)"
                class="w-full p-2 border border-gray-400 rounded-sm mb-4 focus:outline-none focus:border-black"
                onkeydown="if(event.key === 'Enter') { submitNewSession(); }">
            <div class="flex justify-end space-x-3">
                <button onclick="hideModal()"
                    class="px-4 py-2 text-sm bg-white text-gray-700 border border-gray-400 hover:bg-gray-100 rounded-sm">
                    Cancel
                </button>
                <button id="create-session-button" onclick="submitNewSession()"
                    class="px-4 py-2 text-sm bg-black text-white hover:bg-gray-800 rounded-sm">
                    Create Session
                </button>
            </div>
        </div>
    </div>


</body>

</html>